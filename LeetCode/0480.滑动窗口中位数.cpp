#include "header.h"

/*

480. 滑动窗口中位数

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：
[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。
你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

示例：
给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3

窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]

提示：
你可以假设 k 始终有效，即：k 始终小于等于输入的非空数组的元素个数
与真实值误差在 10^-5 以内的答案将被视作正确答案

*/

class Solution {
private:
	priority_queue<int> small;
	priority_queue<int, vector<int>, greater<int>> big;
	unordered_map<int, int> del;

public:
	vector<double> medianSlidingWindow(vector<int> &nums, int k) {
		for (int i = 0; i < k; ++i) small.push(nums[i]);
		for (int i = 0; i < k / 2; ++i) {
			big.push(small.top());
			small.pop();
		}
		vector<double> res{ getMid(k) };
		for (int i = k; i < nums.size(); ++i) {
			int lo = nums[i - k], hi = nums[i];
			++del[lo];
			if (lo <= small.top()) {
				big.push(hi);
				small.push(big.top());
				big.pop();
			} else {
				small.push(hi);
				big.push(small.top());
				small.pop();
			}
			// 存在重复元素，务必先删除small堆里的
			while (!small.empty() && del.count(small.top())) {
				--del[small.top()];
				if (!del[small.top()]) del.erase(small.top());
				small.pop();
			}
			while (!big.empty() && del.count(big.top())) {
				--del[big.top()];
				if (!del[big.top()]) del.erase(big.top());
				big.pop();
			}
			res.push_back(getMid(k));
		}
		return res;
	}

private:
	double getMid(int k) {
		if (k & 1) return small.top();
		else return ((long long)(small.top()) + big.top()) / 2.0;
	}
};
